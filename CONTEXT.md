# Project Context: Low-Poly Image to Mesh Converter

## 1. Project Goal
The objective is to build a Python-based pipeline that takes a raster "low-poly style" image (generated by Gen AI) and reverse-engineers it into a valid 2D triangular mesh.

**Input:** A raster image (PNG/JPG) featuring flat-shaded, low-poly aesthetics.
**Output:** A 3D mesh file (OBJ or GLTF) where:
* Vertices match the visual corners of the polygons in the image.
* Topology uses **Constrained Conforming Delaunay Triangulation**.
* "Merged" faces (neighbors with identical colors) are handled by decomposing the resulting polygon into clean triangles.
* Each face is assigned a single flat color sampled from the original image.

## 2. Core Constraints & Requirements
* **Topology Robustness:** The pipeline must handle cases where multiple source triangles have merged into a single color region (Polygon). It must triangulate the interior of these regions cleanly.
* **Precision:** Edges in the image must become constrained edges in the mesh.
* **Coloring:** Per-face flat colors.
* **Automation:** Zero manual masking.

## 3. The Algorithm Pipeline (Revised)
The agent should implement a "Region-Based" approach rather than simple edge detection to handle invisible edges.

### Phase A: Segmentation (The "Map")
1.  **Denoise:** Apply `cv2.bilateralFilter` to smooth surfaces while keeping edges sharp.
2.  **Quantize:** Use `sklearn.cluster.KMeans` (or `MiniBatchKMeans`) to enforce a strict color palette (k=32 to 64). This merges noisy pixels into solid "Islands" of color.

### Phase B: Polygon Extraction
1.  **Region Iteration:** Iterate through each unique color mask from the quantized image.
2.  **Contour Tracing:** For each color mask, use `cv2.findContours` (with `RETR_CCOMP` to catch holes) to find the boundaries of that color region.
3.  **Simplification:** Apply `cv2.approxPolyDP` to every contour.
    * *Goal:* Turn pixelated blobs into clean vector Polygons.
    * *Output:* A list of segments (edges) defining the boundaries of every color patch.

### Phase C: Constrained Triangulation
1.  **PSLG Construction:** Build a Planar Straight Line Graph (PSLG) using the segments from Phase B.
    * **Vertices:** All points from the simplified contours.
    * **Segments:** The lines connecting them.
2.  **The Triangulation:** Use the `triangle` library.
    * **Function:** `triangle.triangulate(dict(vertices=..., segments=...), opts='pqa100')`
    * **Flag 'p':** Triangulates a Polygon (respects the segments).
    * **Flag 'q':** Quality mesh generation. Ensures no triangle has angles < 20 degrees.
    * **Flag 'a':** Area constraint (optional). Prevents massive triangles in merged regions by limiting maximum triangle area (e.g., `a100`). **This solves the "invisible edge" issue by forcing subdivision of large merged faces.**
3.  **Color Assignment:**
    * For each resulting triangle face, calculate the centroid.
    * Sample the *quantized* image at the centroid.
    * Assign color.

## 4. Tech Stack & Libraries
* **Language:** Python 3.11+
* **Image Processing:** `opencv-python` (cv2)
* **Math/Data:** `numpy`
* **Clustering:** `scikit-learn` (for K-Means)
* **Triangulation:** `triangle` (Python wrapper for Jonathan Shewchuk's library).
    * *Note:* This library is essential for the `opts='pq'` functionality.
* **3D Export:** `trimesh`
(Iistalled via uv)

## 5. Implementation Notes for the Agent
* **Handling Shared Edges:** When extracting contours for adjacent regions, you will get duplicate vertices/edges along the boundary. You must merge duplicate vertices (using a spatial KD-tree or simple distance threshold) before triangulation to ensure the mesh is "watertight" (connected) and not just a collection of disconnected islands.
* **Coordinate Systems:** Image (0,0) is top-left. 3D Mesh (0,0) is usually center or bottom-left. Ensure Y-flip is applied.